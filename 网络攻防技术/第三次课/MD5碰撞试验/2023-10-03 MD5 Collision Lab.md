### Task 1: 生成两个具有相同MD5值的不同的文件

#### 用到的工具

- md5collgen
- diff
- hexdump
- md5sum
#### MD5原理：

- MD5将输入的数据按照64字节一组（$M1-Mn$）进行切分，然后在这些分组上进行迭代地计算。其核心是压缩函数，其接受两个输入，分别是64字节的数据分组和前一次迭代的输出，压缩函数compression function会输出128位的$IHV$（intermediate hash value），这个输出将在下一次迭代时参与运算。如果当前的迭代是最后一次，$IHV$就是最终的hash值。而第一次迭代$IHV_0$的$IHV$的输入是固定值。
 ![[截屏2023-10-06 18.29.32.png]]

#### md5collgen原理：

![[Pasted image 20231006180538.png]]

#### 实验过程

	由于本机系统环境为macOS且为ARM架构，故自行下载md5collgen并编译。首先创建一个prefix文件，用于填充前缀。这里prefix文件内容为Nothing else matters

![[截屏2023-10-06 18.02.04.png]]

采用md5collgen工具，以prefix.txt为前缀，填充MD5值。同时使用diff查看两文件是否相同

![[截屏2023-10-06 18.10.11.png]]

结果不同。为了更精确的确认不同点，采用linux自带的hexdump工具进行查看

![[截屏2023-10-06 18.11.16.png]]

可以观察到在00000050、00000090、000000a0和000000b0位置均有明显不同。于是查看二者的md5值：

![[截屏2023-10-06 18.19.48.png]]

完全一致。于是我们成功完成Task 1。

#### Questions
#####     Question 1: If the length of your prefix file is not multiple of 64, what is going to happen?
#####         A: 前缀部分不足64字节的部分被0填充（从上述实验截图可以看出）
#####     Question 2: Create a prefix file with exactly 64 bytes, and run the collision tool again, and see what happens.

#####         A: 首先创建一个大小为64字节的前缀文件，再次运行Task1的步骤

![[截屏2023-10-06 18.25.45.png]]

可以发现之前被0填充的prefix部分已经被文件内容所替代。同时，在结尾部分由0a标志着字符串的结束。

![[截屏2023-10-06 18.27.41.png]]
##### Question 3: Are the data (128 bytes) generated by md5collgen completely different for the two output files? Please identify all the bytes that are different.
#####         A: 并不是完全不同。根据多次试验，会有3byte左右的数据不同，并且每次不同的数据点也不同。具体不同点上述实验已经给出。

### Task 2: 理解MD5的属性

对于两个不同但具有相同MD5值的文件，为他们添加相同的后缀，我们得到新的文件。对新的文件检查MD5值，发现他们仍然相等。这说明**对于MD5值相同的两份文件，在其后面添加相同的后缀，得到的新文件的MD5值仍然相等。**

![[截屏2023-10-06 18.48.36.png]]

### Task 3: 生成两个具有相同MD5值的可执行文件

#### 实验要求：给定如下C程序，创建该程序的两个不同版本，使得其xyz数组的内容不同，但可执行文件的哈希值相同。

```C
#include <stdio.h>
unsigned char xyz[200] = {
/* The actual contents of this array are up to you */
};
int main() {
	int i;
	for (i=0; i<200; i++){
		printf("%x", xyz[i]);
	}
	printf("\n");
}
```

修改后给出如下程序，首尾不相同是为了在检查二进制时方便区分。


![[截屏2023-10-06 19.42.42.png]]

通过gcc编译后，找到xyz数组对应的二进制文件中的位置：

![[截屏2023-10-06 19.45.35.png]]

这里我们在0x10040到0x10107（我们填充的xyz数组的位置）中挑选一个十进制能被64整除的地址。不妨挑选0x10050，刚好被64整除。用0x10050之前的字节作为prefix，0x10050-0x100D0的字节作为128字节的区域，然后0x100D1以及之后的字节作为suffix。

![[截屏2023-10-06 19.57.49.png]]

查看prefix和suffix

![[截屏2023-10-06 20.03.39.png]]

![[截屏2023-10-06 20.04.30.png]]

进行完成上述操作后，我们利用md5collgen来生成两个不同文件，同时用vimdiff查看二者不同。可以看到明显out1.bin与out2.bin中<8e>与<8f>不同。

![[截屏2023-10-06 20.18.01.png]]

![[截屏2023-10-06 20.11.51.png]]

我们将suffix接到生成的文件后方，并chmod +x赋予执行权限，执行效果如下：

![[截屏2023-10-06 20.19.18.png]]

因此实验三到这里结束，我们成功生成了具有相同MD5值的不同的可执行文件。

### Task 4: 在 Task 3 的基础上，让可执行文件代码逻辑不同

根据Manual的指导，我们构造以下程序：
```C
#include <stdio.h>
unsigned char X[200] = {
	'6', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', '6'
};
unsigned char Y[200] = {
	'6', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R',
	'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', '6'
};
int main()
{
	int flag=1;
	for(int i = 0; i < 200; i++)
		{
			if(X[i]!=Y[i])
			flag=0;
		}
	if(flag)
		printf("Hello World!\n");
	else
		printf("Ruin the World!\n");
}
```

#### 操作流程

按照Task3的流程操作。我们只需要修改两个由md5collgen生成的源文件，修改其中一个使得X数组与Y数组不一样，即可触发恶意代码。

具体的操作流程如下：
 - 利用md5collgen生成两个具有相同md5值的文件（但本身不同）
 - 将其中的一个生成文件的后128字节填充进X数组与Y数组，此时两个数组相同，所以应当执行良性代码
 - 将两个生成文件的后128字节分别填充到X数组与Y数组中，此时两数组相同，应当执行恶意代码。
 - 根据我们了解的MD5函数的特性，我们知道这两个可执行文件一定具有相同的MD5值。

![[截屏2023-10-06 21.08.19.png]]

查看植入数组位置

![[截屏2023-10-06 21.11.37.png]]

采用与Task 3相同的方法先构造两个MD5值相同的文件prefix4_1和prefix4_2。

![[截屏2023-10-06 21.19.30.png]]

查看编译后的可执行程序中的X数组与Y数组的位置：

![[截屏2023-10-07 10.39.11.png]]

可以看到，X数组位于0x10038到0x100ff, Y数组位于0x10100到0x101c7。我们考虑直接将prefix4_1和prefix4_2中的最后128字节取出来备用。

![[截屏2023-10-07 11.32.45.png]]

将ArraySample1填充到task4中的0x10038到0x100B8位置，以及0x10100到0x10180位置：（task41，task42为task4的副本）

![[截屏2023-10-07 11.42.38.png]]

将0x100B8到0x10100中间的部分截出：

![[截屏2023-10-07 11.47.14.png]]

取出中间部分：

![[截屏2023-10-07 11.48.22.png]]

将中间部分接到前缀部分：

![[截屏2023-10-07 11.49.11.png]]

对于head1，我们仍然用ArraySample1填充Y数组部分，但是对于head2，我们用ArraySample2来填充，用于触发恶意代码：

![[截屏2023-10-07 11.51.41.png]]

将第二个字符串之后截出作为suffix：查看知只需截出0x101c8之后的数据。

![[截屏2023-10-07 11.52.42.png]]

截断后的suffix如下图所示：

![[截屏2023-10-07 11.56.05.png]]

拼接结果：

![[截屏2023-10-07 11.57.36.png]]

赋予执行权限，最终结果如下图所示：

![[截屏2023-10-07 12.00.50.png]]

检查文件的md5值：

![[截屏2023-10-07 12.02.20.png]]

一致，实验四完成